import fs from 'fs';
import { useLogger, defineNuxtModule, createResolver, addPlugin, addImports, addComponentsDir, addTemplate, resolveModule } from '@nuxt/kit';
import { genSafeVariableName, genImport } from 'knitwork';
import defu from 'defu';
import { hash } from 'ohash';
import { resolve, join, relative } from 'pathe';
import { listen } from 'listhen';
import { createStorage } from 'unstorage';
import { withTrailingSlash } from 'ufo';
import fsDriver from 'unstorage/drivers/fs';
import httpDriver from 'unstorage/drivers/http';
import githubDriver from 'unstorage/drivers/github';
import { WebSocketServer } from 'ws';

// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);


const name = "@nuxt/content";
const version = "2.1.0";

const logger = useLogger("@nuxt/content");
const CACHE_VERSION = 2;
const MOUNT_PREFIX = "content:source:";
const PROSE_TAGS = [
  "p",
  "a",
  "blockquote",
  "code-inline",
  "code",
  "em",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "img",
  "ul",
  "ol",
  "li",
  "strong",
  "table",
  "thead",
  "tbody",
  "td",
  "th",
  "tr"
];
const unstorageDrivers = {
  fs: fsDriver,
  http: httpDriver,
  github: githubDriver
};
function getMountDriver(mount) {
  if (unstorageDrivers[mount.driver]) {
    return unstorageDrivers[mount.driver](mount);
  }
  try {
    return require(mount.driver).default(mount);
  } catch (e) {
    console.error("Couldn't load driver", mount.driver);
  }
}
function useContentMounts(nuxt, storages) {
  const key = (path, prefix = "") => `${MOUNT_PREFIX}${path.replace(/[/:]/g, "_")}${prefix.replace(/\//g, ":")}`;
  if (Array.isArray(storages)) {
    logger.warn("Using array syntax to define sources is deprecated. Consider using object syntax.");
    storages = storages.reduce((mounts, storage) => {
      if (typeof storage === "string") {
        mounts[key(storage)] = {
          name: storage,
          driver: "fs",
          prefix: "",
          base: resolve(nuxt.options.srcDir, storage)
        };
      }
      if (typeof storage === "object") {
        mounts[key(storage.name, storage.prefix)] = storage;
      }
      return mounts;
    }, {});
  } else {
    storages = Object.entries(storages).reduce((mounts, [name, storage]) => {
      mounts[key(storage.name || name, storage.prefix)] = storage;
      return mounts;
    }, {});
  }
  const defaultStorage = key("content");
  if (!storages[defaultStorage]) {
    storages[defaultStorage] = {
      name: defaultStorage,
      driver: "fs",
      base: resolve(nuxt.options.srcDir, "content")
    };
  }
  return storages;
}
function createWebSocket() {
  const wss = new WebSocketServer({ noServer: true });
  const serve = (req, socket = req.socket, head = "") => wss.handleUpgrade(req, socket, head, (client) => wss.emit("connection", client, req));
  const broadcast = (data) => {
    data = JSON.stringify(data);
    for (const client of wss.clients) {
      try {
        client.send(data);
      } catch (err) {
      }
    }
  };
  return {
    serve,
    broadcast,
    close: () => {
      wss.clients.forEach((client) => client.close());
      return new Promise((resolve2) => wss.close(resolve2));
    }
  };
}
function processMarkdownOptions(options) {
  return {
    ...options,
    remarkPlugins: resolveMarkdownPlugins(options.remarkPlugins),
    rehypePlugins: resolveMarkdownPlugins(options.rehypePlugins)
  };
}
function resolveMarkdownPlugins(plugins) {
  if (Array.isArray(plugins)) {
    return Object.values(plugins).reduce((plugins2, plugin) => {
      const [name, pluginOptions] = Array.isArray(plugin) ? plugin : [plugin, {}];
      plugins2[name] = pluginOptions;
      return plugins2;
    }, {});
  }
  return plugins || {};
}

const module = defineNuxtModule({
  meta: {
    name,
    version,
    configKey: "content",
    compatibility: {
      nuxt: "^3.0.0-rc.3"
    }
  },
  defaults: {
    base: "_content",
    watch: {
      ws: {
        port: 4e3,
        showURL: false
      }
    },
    sources: {},
    ignores: ["\\.", "-"],
    locales: [],
    defaultLocale: void 0,
    highlight: false,
    markdown: {
      tags: Object.fromEntries(PROSE_TAGS.map((t) => [t, `prose-${t}`]))
    },
    yaml: {},
    csv: {
      delimeter: ",",
      json: true
    },
    navigation: {
      fields: []
    },
    documentDriven: false
  },
  async setup(options, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const resolveRuntimeModule = (path) => resolveModule(path, { paths: resolve("./runtime") });
    const contentContext = {
      transformers: [],
      ...options
    };
    if (nuxt.options.vite !== false) {
      nuxt.options.vite = defu(
        nuxt.options.vite === true ? {} : nuxt.options.vite,
        {
          optimizeDeps: {
            include: ["html-tags"]
          }
        }
      );
    }
    addPlugin(resolveRuntimeModule("./plugins/ws"));
    nuxt.hook("nitro:config", (nitroConfig) => {
      nitroConfig.prerender = nitroConfig.prerender || {};
      nitroConfig.prerender.routes = nitroConfig.prerender.routes || [];
      nitroConfig.handlers = nitroConfig.handlers || [];
      nitroConfig.handlers.push(
        {
          method: "get",
          route: `/api/${options.base}/query/:qid`,
          handler: resolveRuntimeModule("./server/api/query")
        },
        {
          method: "get",
          route: `/api/${options.base}/query`,
          handler: resolveRuntimeModule("./server/api/query")
        },
        {
          method: "get",
          route: `/api/${options.base}/cache`,
          handler: resolveRuntimeModule("./server/api/cache")
        }
      );
      if (!nuxt.options.dev) {
        nitroConfig.prerender.routes.push("/api/_content/cache");
      }
      const sources = useContentMounts(nuxt, contentContext.sources);
      nitroConfig.devStorage = Object.assign(nitroConfig.devStorage || {}, sources);
      nitroConfig.devStorage["cache:content"] = {
        driver: "fs",
        base: resolve(nuxt.options.buildDir, "content-cache")
      };
      for (const source of Object.values(sources)) {
        if (source.driver === "fs" && source.base.includes(nuxt.options.srcDir)) {
          const wildcard = join(source.base, "**/*").replace(withTrailingSlash(nuxt.options.srcDir), "");
          nuxt.options.ignore.push(
            wildcard,
            `!${wildcard}.vue`
          );
        }
      }
      nitroConfig.bundledStorage = nitroConfig.bundledStorage || [];
      nitroConfig.bundledStorage.push("/cache/content");
      nitroConfig.externals = defu(typeof nitroConfig.externals === "object" ? nitroConfig.externals : {}, {
        inline: [
          resolve("./runtime")
        ]
      });
      nitroConfig.alias = nitroConfig.alias || {};
      nitroConfig.alias["#content/server"] = resolveRuntimeModule("./server");
      const transformers = contentContext.transformers.map((t) => {
        const name2 = genSafeVariableName(relative(nuxt.options.rootDir, t)).replace(/_(45|46|47)/g, "_") + "_" + hash(t);
        return { name: name2, import: genImport(t, name2) };
      });
      nitroConfig.virtual = nitroConfig.virtual || {};
      nitroConfig.virtual["#content/virtual/transformers"] = [
        ...transformers.map((t) => t.import),
        `export const transformers = [${transformers.map((t) => t.name).join(", ")}]`,
        'export const getParser = (ext) => transformers.find(p => ext.match(new RegExp(p.extensions.join("|"),  "i")) && p.parse)',
        'export const getTransformers = (ext) => transformers.filter(p => ext.match(new RegExp(p.extensions.join("|"),  "i")) && p.transform)',
        "export default () => {}"
      ].join("\n");
    });
    addImports([
      { name: "queryContent", as: "queryContent", from: resolveRuntimeModule("./composables/query") },
      { name: "useContentHelpers", as: "useContentHelpers", from: resolveRuntimeModule("./composables/helpers") },
      { name: "useContentHead", as: "useContentHead", from: resolveRuntimeModule("./composables/head") },
      { name: "withContentBase", as: "withContentBase", from: resolveRuntimeModule("./composables/utils") },
      { name: "useUnwrap", as: "useUnwrap", from: resolveRuntimeModule("./composables/utils") }
    ]);
    await addComponentsDir({
      path: resolve("./runtime/components"),
      pathPrefix: false,
      prefix: "",
      level: 999,
      global: true
    });
    const typesPath = addTemplate({
      filename: "types/content.d.ts",
      getContents: () => [
        "declare module '#content/server' {",
        `  const serverQueryContent: typeof import('${resolve("./runtime/server")}').serverQueryContent`,
        `  const parseContent: typeof import('${resolve("./runtime/server")}').parseContent`,
        "}"
      ].join("\n")
    }).dst;
    nuxt.hook("prepare:types", (options2) => {
      options2.references.push({ path: typesPath });
    });
    const _layers = [...nuxt.options._layers].reverse();
    for (const layer of _layers) {
      const srcDir = layer.config.srcDir;
      const globalComponents = resolve(srcDir, "components/content");
      const dirStat = await fs.promises.stat(globalComponents).catch(() => null);
      if (dirStat && dirStat.isDirectory()) {
        if (nuxt.options._layers.length === 1) {
          logger.success("Using `~/components/content` for components in Markdown");
        }
        nuxt.hook("components:dirs", (dirs) => {
          dirs.unshift({
            path: globalComponents,
            global: true,
            pathPrefix: false,
            prefix: ""
          });
        });
      } else if (nuxt.options._layers.length === 1) {
        const componentsDir = resolve(srcDir, "components/");
        const componentsDirStat = await fs.promises.stat(componentsDir).catch(() => null);
        if (componentsDirStat && componentsDirStat.isDirectory()) {
          logger.info("Please create `~/components/content` and restart the Nuxt server to use components in Markdown");
        }
      }
    }
    if (options.navigation) {
      addImports({ name: "fetchContentNavigation", as: "fetchContentNavigation", from: resolveRuntimeModule("./composables/navigation") });
      nuxt.hook("nitro:config", (nitroConfig) => {
        nitroConfig.handlers = nitroConfig.handlers || [];
        nitroConfig.handlers.push({
          method: "get",
          route: `/api/${options.base}/navigation/:qid`,
          handler: resolveRuntimeModule("./server/api/navigation")
        });
        nitroConfig.handlers.push({
          method: "get",
          route: `/api/${options.base}/navigation`,
          handler: resolveRuntimeModule("./server/api/navigation")
        });
      });
    }
    if (options.highlight) {
      contentContext.transformers.push(resolveRuntimeModule("./transformers/shiki"));
      contentContext.highlight.apiURL = `/api/${options.base}/highlight`;
      nuxt.hook("nitro:config", (nitroConfig) => {
        nitroConfig.handlers = nitroConfig.handlers || [];
        nitroConfig.handlers.push({
          method: "post",
          route: `/api/${options.base}/highlight`,
          handler: resolveRuntimeModule("./server/api/highlight")
        });
      });
    }
    if (options.documentDriven) {
      const defaultDocumentDrivenConfig = {
        page: true,
        navigation: true,
        surround: true,
        globals: {},
        layoutFallbacks: ["theme"],
        injectPage: true
      };
      if (options.documentDriven === true) {
        options.documentDriven = defaultDocumentDrivenConfig;
      } else {
        options.documentDriven = {
          ...defaultDocumentDrivenConfig,
          ...options.documentDriven
        };
      }
      if (options.navigation) {
        options.navigation.fields.push("layout");
      }
      addImports([
        { name: "useContentState", as: "useContentState", from: resolveRuntimeModule("./composables/content") },
        { name: "useContent", as: "useContent", from: resolveRuntimeModule("./composables/content") }
      ]);
      addPlugin(resolveRuntimeModule("./plugins/documentDriven"));
      if (options.documentDriven.injectPage) {
        nuxt.options.pages = true;
        nuxt.hook("pages:extend", (pages) => {
          if (!pages.find((page) => page.path === "/:slug(.*)*")) {
            pages.unshift({
              name: "slug",
              path: "/:slug(.*)*",
              file: resolveRuntimeModule("./pages/document-driven.vue"),
              children: []
            });
          }
        });
        nuxt.hook("app:resolve", async (app) => {
          if (app.mainComponent?.includes("@nuxt/ui-templates")) {
            app.mainComponent = resolveRuntimeModule("./app.vue");
          } else {
            const appContent = await fs.promises.readFile(app.mainComponent, { encoding: "utf-8" });
            if (appContent.includes("<NuxtLayout") || appContent.includes("<nuxt-layout")) {
              logger.warn([
                "Using `<NuxtLayout>` inside `app.vue` will cause unwanted layout shifting in your application.",
                "Consider removing `<NuxtLayout>` from `app.vue` and using it in your pages."
              ].join(""));
            }
          }
        });
      }
    } else {
      addImports([
        { name: "useContentDisabled", as: "useContentState", from: resolveRuntimeModule("./composables/utils") },
        { name: "useContentDisabled", as: "useContent", from: resolveRuntimeModule("./composables/utils") }
      ]);
    }
    await nuxt.callHook("content:context", contentContext);
    contentContext.defaultLocale = contentContext.defaultLocale || contentContext.locales[0];
    const cacheIntegrity = hash({
      locales: options.locales,
      options: options.defaultLocale,
      markdown: options.markdown,
      hightlight: options.highlight
    });
    contentContext.markdown = processMarkdownOptions(contentContext.markdown);
    nuxt.options.runtimeConfig.public.content = defu(nuxt.options.runtimeConfig.public.content, {
      base: options.base,
      tags: contentContext.markdown.tags,
      highlight: options.highlight,
      wsUrl: "",
      documentDriven: options.documentDriven
    });
    nuxt.options.runtimeConfig.content = {
      cacheVersion: CACHE_VERSION,
      cacheIntegrity,
      ...contentContext
    };
    nuxt.hook("tailwindcss:config", (tailwindConfig) => {
      tailwindConfig.content = tailwindConfig.content ?? [];
      tailwindConfig.content.push(resolve(nuxt.options.buildDir, "content-cache", "parsed/**/*.md"));
    });
    if (!nuxt.options.dev) {
      nuxt.hook("build:before", async () => {
        const storage = createStorage();
        const sources = useContentMounts(nuxt, contentContext.sources);
        sources["cache:content"] = {
          driver: "fs",
          base: resolve(nuxt.options.buildDir, "content-cache")
        };
        for (const [key, source] of Object.entries(sources)) {
          storage.mount(key, getMountDriver(source));
        }
        let keys = await storage.getKeys("content:source");
        const invalidKeyCharacters = `'"?#/`.split("");
        const contentIgnores = contentContext.ignores.map(
          (p) => typeof p === "string" ? new RegExp(`^${p}|:${p}`) : p
        );
        keys = keys.filter((key) => {
          if (key.startsWith("preview:") || contentIgnores.some((prefix) => prefix.test(key))) {
            return false;
          }
          if (invalidKeyCharacters.some((ik) => key.includes(ik))) {
            return false;
          }
          return true;
        });
        await Promise.all(
          keys.map(async (key) => await storage.setItem(
            `cache:content:parsed:${key.substring(15)}`,
            await storage.getItem(key)
          ))
        );
      });
      return;
    }
    nuxt.hook("nitro:init", async (nitro) => {
      if (!options.watch || !options.watch.ws) {
        return;
      }
      const ws = createWebSocket();
      nitro.hooks.hook("close", async () => {
        await ws.close();
      });
      const { server, url } = await listen(() => "Nuxt Content", options.watch.ws);
      server.on("upgrade", ws.serve);
      nitro.options.runtimeConfig.public.content.wsUrl = url.replace("http", "ws");
      await nitro.storage.watch(async (event, key) => {
        if (!key.startsWith(MOUNT_PREFIX)) {
          return;
        }
        key = key.substring(MOUNT_PREFIX.length);
        await nitro.storage.removeItem("cache:content:content-index.json");
        ws.broadcast({ event, key });
      });
    });
  }
});

export { module as default };
